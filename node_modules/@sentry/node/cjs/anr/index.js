Object.defineProperty(exports, '__esModule', { value: true });

const utils = require('@sentry/utils');
const child_process = require('child_process');
const inspector = require('inspector');
const _debugger = require('./debugger.js');
const core = require('@sentry/core');

const DEFAULT_INTERVAL = 50;
const DEFAULT_HANG_THRESHOLD = 5000;

/**
 * A node.js watchdog timer
 * @param pollInterval The interval that we expect to get polled at
 * @param anrThreshold The threshold for when we consider ANR
 * @param callback The callback to call for ANR
 * @returns A function to call to reset the timer
 */
function watchdogTimer(pollInterval, anrThreshold, callback) {
  let lastPoll = process.hrtime();
  let triggered = false;

  setInterval(() => {
    const [seconds, nanoSeconds] = process.hrtime(lastPoll);
    const diffMs = Math.floor(seconds * 1e3 + nanoSeconds / 1e6);

    if (triggered === false && diffMs > pollInterval + anrThreshold) {
      triggered = true;
      callback();
    }

    if (diffMs < pollInterval + anrThreshold) {
      triggered = false;
    }
  }, 20);

  return () => {
    lastPoll = process.hrtime();
  };
}

function sendEvent(blockedMs, frames) {
  const event = {
    level: 'error',
    exception: {
      values: [
        {
          type: 'ApplicationNotResponding',
          value: `Application Not Responding for at least ${blockedMs} ms`,
          stacktrace: { frames },
          mechanism: {
            // This ensures the UI doesn't say 'Crashed in' for the stack trace
            type: 'ANR',
          },
        },
      ],
    },
  };

  core.captureEvent(event);

  void core.flush(3000).then(() => {
    // We only capture one event to avoid spamming users with errors
    process.exit();
  });
}

function startChildProcess(options) {
  function log(message, err) {
    if (options.debug) {
      if (err) {
        utils.logger.log(`[ANR] ${message}`, err);
      } else {
        utils.logger.log(`[ANR] ${message}`);
      }
    }
  }

  try {
    const env = { ...process.env };

    if (options.captureStackTrace) {
      inspector.open();
      env.SENTRY_INSPECT_URL = inspector.url();
    }

    const child = child_process.fork(options.entryScript, {
      env,
      stdio: options.debug ? 'inherit' : 'ignore',
    });
    // The child process should not keep the main process alive
    child.unref();

    const timer = setInterval(() => {
      try {
        // message the child process to tell it the main event loop is still running
        child.send('ping');
      } catch (_) {
        //
      }
    }, options.pollInterval);

    const end = (err) => {
      clearInterval(timer);
      log('Child process ended', err);
    };

    child.on('error', end);
    child.on('disconnect', end);
    child.on('exit', end);
  } catch (e) {
    log('Failed to start child process', e);
  }
}

function handleChildProcess(options) {
  function log(message) {
    if (options.debug) {
      utils.logger.log(`[ANR child process] ${message}`);
    }
  }

  log('Started');

  core.addGlobalEventProcessor(event => {
    // Strip sdkProcessingMetadata from all child process events to remove trace info
    delete event.sdkProcessingMetadata;
    event.tags = {
      ...event.tags,
      'process.name': 'ANR',
    };
    return event;
  });

  let debuggerPause;

  // if attachStackTrace is enabled, we'll have a debugger url to connect to
  if (process.env.SENTRY_INSPECT_URL) {
    log('Connecting to debugger');

    debuggerPause = _debugger.captureStackTrace(process.env.SENTRY_INSPECT_URL, frames => {
      log('Capturing event with stack frames');
      sendEvent(options.anrThreshold, frames);
    });
  }

  async function watchdogTimeout() {
    log('Watchdog timeout');
    const pauseAndCapture = await debuggerPause;

    if (pauseAndCapture) {
      log('Pausing debugger to capture stack trace');
      pauseAndCapture();
    } else {
      log('Capturing event');
      sendEvent(options.anrThreshold);
    }
  }

  const ping = watchdogTimer(options.pollInterval, options.anrThreshold, watchdogTimeout);

  process.on('message', () => {
    ping();
  });
}

/**
 * **Note** This feature is still in beta so there may be breaking changes in future releases.
 *
 * Starts a child process that detects Application Not Responding (ANR) errors.
 *
 * It's important to await on the returned promise before your app code to ensure this code does not run in the ANR
 * child process.
 *
 * ```js
 * import { init, enableAnrDetection } from '@sentry/node';
 *
 * init({ dsn: "__DSN__" });
 *
 * // with ESM + Node 14+
 * await enableAnrDetection({ captureStackTrace: true });
 * runApp();
 *
 * // with CJS or Node 10+
 * enableAnrDetection({ captureStackTrace: true }).then(() => {
 *   runApp();
 * });
 * ```
 */
function enableAnrDetection(options) {
  const isChildProcess = !!process.send;

  const anrOptions = {
    entryScript: options.entryScript || process.argv[1],
    pollInterval: options.pollInterval || DEFAULT_INTERVAL,
    anrThreshold: options.anrThreshold || DEFAULT_HANG_THRESHOLD,
    captureStackTrace: !!options.captureStackTrace,
    debug: !!options.debug,
  };

  if (isChildProcess) {
    handleChildProcess(anrOptions);
    // In the child process, the promise never resolves which stops the app code from running
    return new Promise(() => {
      // Never resolve
    });
  } else {
    startChildProcess(anrOptions);
    // In the main process, the promise resolves immediately
    return Promise.resolve();
  }
}

exports.enableAnrDetection = enableAnrDetection;
//# sourceMappingURL=index.js.map
